# final-project-swe4s_mclj
![](https://travis-ci.com/cu-swe4s-fall-2019/final-project-swe4s_mclj.svg?branch=master)

## Description
This is a repository for the final project of the course Software Engineering for Scientists (CSCI 7000) at CU Boulder, of which the goal is to develope a software package able to perform a Monte Carlo simulation of Lennard-Jones particlees in canonical ensembles. The repository includes the following files:
- `monte_carlo.py`: The main program of the package, which is able to perform a Monte Carlo simulation of Lennard Jones particles given specified parameters. 
- `test_monte_carlo.py`: The unit tests of `monte_carlo.py`.
- `test_monte_carlo.py`: The funtinoal tests of `monte_carlo.py`.
- `energy.py`: A Python library which include several models and methods for energy calculations. 
- `test_energy.py`: The unit tests of `energy.py`.
- `test_energy.sh`: The functional tests of `energy.py`.

#### Requirements fulfilled
Throughout the development, to apply and extend the knowledge learned from the course, all the following requirements are fulfilled:

- The software development follows the best practices of GitHub workflow and test-driven development (TDD).
- All the python codes conform with PEP8 coding style.
- All the Python modules have their own corresponding unit tests and functional test.
- Continuous integration was performed using Travis CI.
- `setup.py` and relevant files were added to distribute the package and enable its installation.
- Benchmarking and profiling were performed to compare the computational costs of using different data strcutre, either a Numpy array or a dictionary, which is the implementation of hash tables in Python.

#### The scieintific goals of the project
The major goal of this software package, is to perform a Monte Carlo simulation of Lennard-Jones particles in canonical (NVT) ensembles, and compare the result with [ the benchmark provided by NIST](https://mmlapps.nist.gov/srs/LJ_PURE/mc.htm), which provides the resulting potential energy of the system given different reduced temperatures and reduced densities. In the simulation, $500$ particles were placed randomly in the box such that the reduced density ($\rho^{*}$) was $0.9$. The reduced temperature ($T^{*}$) was set as $0.9$ to compare with one of the benchmarks. Due to the limitation of time and computation cost, we ran the simulation for 10 million steps, which should be enough to produce a result comparable to NIST benchmark, which required 250 million steps in the production simulation. In addition to an animated trajectory generated by [Visual Molecular Dynamics (VMD)](https://www.ks.uiuc.edu/Research/vmd/), the initial and final configuration of the system will be visualized the demonstrate the concept of a Mone Carlo simulation. Note that the parameters such as the reduced temperature and reduced density are allowed to be changed flexibily using different flags. 


## Installation
All the Python scripts are written in Python 3 and teh packages required to run the codes (including the unit tests and functional tests) inlcude: `os`, `sys`, `abc`, `time`, `numpy`, `argparse`, `unittest`, `matplotlib`, and `pycodestyle`. Currently the package can be installed by following the commands below:
```
git clone https://github.com/cu-swe4s-fall-2019/final-project-swe4s_mclj.git
cd EXE_analysis
pip install -e .
```

## Introduction to the project
The goal is this project, is to develop a sfotware package which is able to perform a Monte Carlo simulation of Lennard-Jones fluids. 


## Usage
Use `python monte_carlo.py` to conduct basic simulation. If you want to simulate different configuration, you can set the following arguments to `monte_carlo.py`:
- `-N`: The number of particles in the simulation box. Default: 500.
- `-T`: The reduced temperature ranging from 0 to 1. Default: 0.9.
- `-r`: The reduced density of the particles ranging from 0 to 1. Default: 0.9.
- `-n`: The number of Monte Carlo steps. Default: 1M.
- `-fe`: The output frequency of energy as the stdout. Default: 1000.
- `-ft`: The output frequency of the trajectory data. Default: 100000.
- `-m`: The initial maximum of the displacement. Default: 0.1.
- `-e`: The energy function used to calculate the interactions between the particles in the fluid Default: "UnitLessLJ".
- `-p`: whether to plot the ouput the coordinates on updates

## Profiling and Improvement
**Command**: `python3 -m cProfile -s tottime monte_carlo.py -N 20 -n 100000`
```
65234309 function calls (61272000 primitive calls) in 81.529 seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
3800190   20.090    0.000   20.090    0.000 energy.py:92(calc_energy)
```
To speed up our simulation process, we utilized `cProfile` module to analyze the bottleneck of our program. Based on the profiling result, we want to speed up `calc_energy`. First, let's talk about `calc_energy`. This function takes a floating point `r` (radius) as input, and uses this parameter to calculate the corresponding energy. Thus, in order to improve the performance of `calc_energy`, we added a hash table such as a cache to store calculated energy of known `r`. As the result, the cache makes `calc_energy` around *1.449799197* times faster than original method.
```
69034583 function calls (65072274 primitive calls) in 74.539 seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
3800190   13.387    0.000   13.855    0.000 energy.py:92(calc_energy)
```

## Results
To verify the correctness of our simulation, we compared our result with [the benchmark provided by NIST](https://mmlapps.nist.gov/srs/LJ_PURE/mc.htm).

## Authors
- Wei-Tse Hsu ([wehs7661@colorado.edu]())
- Chi-Ju Wu ([chwu5235@colorado.edu]())